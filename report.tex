% !TEX TS-program = xelatex
%
\documentclass{clseminar}

\input{settings.tex}

\usepackage[english]{babel}
\usepackage{parskip}

\bibfile{references}

\title{Process Calculi for Concurrency}
\author{Markus Reiter, Michael Kaltschmid}
\supervisor{Vincent van Oostrom}

\begin{document}
  \abstract{\input{abstract}}
  \maketitle
  \newpage
  \tableofcontents

  \section{Introduction}
  This report is about $mCRL2$, a rather modern Process Calculi. We will discuss $mCRL2$ itself and concepts which are the base of it.
  \subsection{What is a Process Calculus?}
  A Process Calculus is basically an approach for formally modelling concurrent systems.
  Furthermore it is a tool for high-level description of interactions, communications and synchronizations between processes. \\
  It also provides algebraic laws to allow analyzing and transforming process descriptions and permits formal reasoning about equivalences between processes (e.g., using bisimulation) \\

  \subsection{Focus}
  There are various other forms of Process Calculi like $ACP$, $CCS$, $CSP$, $Join-Calculus$, $\mu-Calculus$, $PEPA$ or $\pi-Calculus$. However we are only going to focus on $ACP$ and $\mu-Calculus$. Specifically on $\mu-Calculus$ since it the core concept of $mCRL2$.

  \section{Labelled Transition Systems}
  A LTS is a directed labelled graph and it consists of a set of state and a set of transitoins labelled with actions that connect the states. Additionally it must have an initial state. It is also important to note that it will deadlock if a reachable state does not terminate and has no outgoing
  transitions. If a state has more than one outgoing transition with the same label to different states, then it is nondeterministic. \\[12pt]
  A LTS is a tuple $(S, A, \to,s_0>)$ where: \\

  \begin{itemize}[noitemsep]
    \item $S$ is a set of states \\
    \item $A$ is a set of actions \\
    \item $\to\ \subseteq S \times A \times S$ is a transition relation \\
    \item $s_0 \in S$ is the initial state \\
  \end{itemize}

  \begin{tabular}{cc}
    \begin{minipage}{.5\linewidth}
      \centering
      \input{graphs/lts_1}
    \end{minipage}
    \begin{minipage}{.5\linewidth}
      \centering
      \input{graphs/lts_2}
    \end{minipage}
  \end{tabular} \\[12pt]

  In the two figures above you can see examples of two LTSs for alarm clocks. The first alarm clock on the left allows for repeated alarms which can be seen by the loop on top of the alarm state. With the second alarm clock it is only possible to signal the alarm once. \\
  Both LTSs are determistic since no state has more than one outgoing transition with the same label to a different state. However we can make the right LTS nondeterministic by drawing a loop on top of the alarm state as you can see in the figure below. \\

  \begin{center}
    \input{graphs/lts_3}
  \end{center}

  \subsection{Bisimulation}
  Bisimulation is a binary relation between LTSs, where LTSs behave the same way in the sense
  that one LTS simulates the other and vice versa. Bisimulation is not the only form of equivalence. We can further differentiate between

  \begin{itemize}[noitemsep]
    \item Trace equivalence: \\
    Two LTSs are equivalent iff they can perform the same sequences of actions, starting from their initial states \\
    \item Strong bisimilarity: \\
    If one LTS can perform an action a then the other LTS must also be able to perform an action a in a way that the resulting states are again related. \\
  \end{itemize}

  \begin{figure}[!ht]
    \resizebox{\textwidth}{!}{\input{graphs/coffee_machines}}
    \caption{Bisimilarity of two coffee machines.}
    \label{fig:coffee_machines}
  \end{figure}

  The two coffee machines in the figures above are trace equivalent but not strongly bisimilar because the resulting states are not related. As an example we can check what happens after inserting a coin. With the first coffee machine we reach state $P2$ and with the second coffee machine we reach either $Q2$ or $Q3$ depending on the choice of beverage.\\
  So the process of inserting a coin and then either getting a coffee or a tea is the same but the path on how we get there is different.

  \section{µ-Calculus}
  As already mentioned before µ-Calculus is an integral part of $mcrl2$. µ-Calculus is an extension of propositional logic and therefore shares some similiarites. \\
  Furthermore it is used to describe and verify properties of LTSs.

  \subsection{Hennessy-Milner Logic}
  \begin{align*}
    \phi ::= \mathit{true}\ |\ \mathit{false}\ |\ \neg \phi\ |\ \phi \land \psi\ |\ \phi \lor \psi\ |\ \phi \to \psi\ |\ \langle a \rangle \phi \ |\ [a]\phi
  \end{align*}
  \begin{itemize}
    \item $\mathit{true}$ is true in each state of a process and $\mathit{false}$ is never true
    \item $\neg ,\ \land\ ,\ \lor$ and $\to$ as in propositional logic
    \item $\langle a \rangle \phi$ is valid whenever an $a-action$ can be performed such that $\phi$ is valid after this $a$ has been done
    \item $[a]\phi$ is valid when for every action $a$ that can be done, $\phi$ holds after doing that $a$
  \end{itemize}

  \subsection{Diamond and Box Modalities}

  Although $\langle a \rangle \phi$ - diamond modality and $[a]\phi$ - box modality look somewhat similar, yet they are very different. In order to show the difference between the two modalities we have four simple LTSs where we take look wheter the box modality or the diamond modality of $a$.

  \resizebox{\textwidth}{!}{
    \newcommand{\valid}{{\color{green} valid}}
    \newcommand{\invalid}{{\color{red} invalid}}
    \renewcommand{\arraystretch}{2}
    \begin{tabular}{l c c c c}
      &

      \begin{tikzpicture}
        \node[vertex] (a) at (0, 1.25) {};
        \node[vertex] [label=right:{$\phi$}] (b) at (0, 0) {};

        \draw[edge] (0, 1.75) to (a);
        \draw[edge] (a) to node [left] {$a$} (b);
      \end{tikzpicture}

      &

      \begin{tikzpicture}
        \node[vertex] (a) at (0, 1.25) {};
        \node[vertex] [label=right:{$\neg\phi$}] (b) at (0, 0) {};

        \draw[edge] (0, 1.75) to (a);
        \draw[edge] (a) to node [left] {$a$} (b);
      \end{tikzpicture}

      &

      \begin{tikzpicture}
        \node[vertex] (a) at (0.75, 1.25) {};
        \node[vertex] [label=left:{$\phi$}] (b) at (0, 0) {};
        \node[vertex] [label=right:{$\neg\phi$}] (c) at (1.5, 0) {};

        \draw[edge] (.75, 1.75) to (a);
        \draw[edge] (a) to node [left] {$a$} (b);
        \draw[edge] (a) to node [right] {$a$} (c);
      \end{tikzpicture}

      &

      \begin{tikzpicture}
        \node[vertex] (a) at (0, 1.25) {};
        \node at (0, -0.175) {};

        \draw[edge] (0, 1.75) to (a);
      \end{tikzpicture}

      \\

      $\langle{}a\rangle{}\phi$ & \valid & \invalid & \valid & \invalid \\

      $[a]\phi$                 & \valid & \invalid & \invalid &  \valid \\
    \end{tabular}
  }\\[6pt]

  In the first LTS a $a$ action is possible to a state where $\phi$ holds and therefore both $\langle{}a\rangle{}\phi$ and $[a]\phi$ are possible. \\
  In the second LTS there is no $a$ action to a state where $\phi$ holds and for that reason both $\langle{}a\rangle{}\phi$ and $[a]\phi$ are not possible. \\
  In the third LTS there is no $a$ action to a state where $\phi$ holds and an $a$ action to a state where $\phi$ does not holds and therefore $\langle{}a\rangle{}\phi$ is valid since there is at least one $a$ action that leads to a valid $\phi$ and $[a]\phi$ is not valid because not every $a$ action results in a valid $[a]\phi$. \\
  In the fourth LTS there is no $a$ action at all and therefore $\langle{}a\rangle{}\phi$ is not valid because, because there needs to be an $a$ action that can be performed and $[a]\phi$ is valid, since there is no action that can be done.


  \section{ACP}

  ACP is the Algebra of Communicating Processes and is used to describe parallel and concurrent processes.

  \cite{groote2014}

  \section{mCRL2}

  \textbf{mCRL2} is a toolset which is used for specifying and analysing behaviour of distributed systems and protocols. We chose this tool because it uses an ACP-like syntax for its formal specification language for processes as well as µ-Calculus for model checking.

  Let's first take a look at the \textbf{mCRL2} syntax for specifying processes. Usually, a process specification file will have a file name of the form \texttt{*.mcrl2}.

  \begin{figure}[!ht]
    \input{listings/mcrl2_syntax}
    \caption{The \textbf{mCRL2} process specification syntax.}
    \label{fig:mcrl2_syntax}
  \end{figure}

  As you can see in the first line in \autoref{fig:mcrl2_syntax}, we specify all available actions using the \texttt{act} keyword. This relates to $a$ in the ACP syntax. Now that we have defined the actions, we can specify the process itself, or processes, if there are more than one. We do this using the \texttt{proc} keywords, followed by the name of the process. In \autoref{fig:mcrl2_syntax} we have three processes, \texttt{P}, \texttt{Q} and \texttt{R}. We then equate every process with a combination of actions, action sequences and action alternatives. In \textbf{mCRL2}, we use \texttt{.} to denote a sequence and \texttt{+} to denote an alternative. This means that process \texttt{P} is a sequence of actions \texttt{a}, \texttt{b} and \texttt{c}. Process \texttt{Q} is a choice between either action \texttt{d} or action \texttt{e}. And finally, process \texttt{R} is a choice betweeen action \texttt{a} and \texttt{b}, followed by \texttt{c}, \texttt{d} and \texttt{e}. Note the parentheses around \texttt{a + b}, since \texttt{.} binds stronger than \texttt{+}. Finally, the \texttt{init} keyword specifies the starting process, in this case \texttt{P}.

  To demonstrate the power of ACP and µ-Calculus in combination with the \textbf{mCRL2} toolset, we will now look at an implementation of the two coffee machines (\autoref{fig:coffee_machines}) in \textbf{mCRL2}.

  First, we have to define the actions for coffee machine 1.

  \begin{lstlisting}[language=mCRL2]
act insert_coin, choose_coffee, choose_tea,
                   pour_coffee,   pour_tea;
  \end{lstlisting}

  The \texttt{insert\_coin} action is self-explanatory. \texttt{choose\_coffee} and \texttt{choose\_tea} denote the actions of pressing either the button for coffee, or the button for tea. And finally, \texttt{pour\_coffee} and \texttt{pour\_tea} denote the action of dispensing either coffee or tea.

  Since coffee machine 2 is trace equivalent to coffee machine 1, it has the same actions.

  Next, we define the process for coffee machine 1.

  \begin{lstlisting}[language=mCRL2]
proc P = insert_coin . (
           choose_coffee . pour_coffee +
           choose_tea . pour_tea
         ) . P;
  \end{lstlisting}

  We start by inserting a coin (\texttt{insert\_coin}). Then, we are left with a choice between choosing coffee and pouring coffee or choosing tea and pouring tea. We see that choosing coffee or tea is tightly coupled to pouring it, since this is a choice between two sequences \texttt{(choose\_coffee . pour\_coffee)} and \texttt{(choose\_tea . pour\_tea)}. This is of course because we don't want the machine to dispense tea when in fact we chose coffee.

  The last action is \texttt{P} itself, which results in a recursion. This is because we want the machine to be reusable.

  We now define the process for coffee machine 2.

  \begin{lstlisting}[language=mCRL2]
proc Q = (
           (insert_coin . choose_coffee . pour_coffee) +
           (insert_coin . choose_tea . pour_tea)
         ) . Q;
  \end{lstlisting}

  For this machine, we specify a process named \texttt{Q}. This process starts with a choice, which is either a sequence of inserting a coin, choosing coffee and pouring coffee or inserting a coin, choosing tea and pouring tea. In comparison to the first machine, the \texttt{insert\_coin} action is now part of the choice between coffee or tea.

  \newpage

  \appendix

\end{document}
